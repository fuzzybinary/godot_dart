import 'package:collection/collection.dart';

import 'code_sink.dart';
import 'godot_api_info.dart';
import 'godot_extension_api_json.dart';
import 'string_extensions.dart';
import 'type_helpers.dart';

const String header = '''// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `godot_dart binding_generator`.
// ignore_for_file: duplicate_import
// ignore_for_file: unused_import
// ignore_for_file: unnecessary_import
// ignore_for_file: unused_field
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_element
// ignore_for_file: constant_identifier_names
''';

extension GodotStringImportHelper on String {
  List<String> findImport() {
    return GodotApiInfo.instance().findImportForType(this);
  }
}

extension GodotListImportHelper<T> on List<T> {
  List<String> findImports(String? Function(T element) typeLocator) {
    final imports = <String>[];
    for (T e in this) {
      final type = typeLocator(e);
      if (type?.findImport() case final import?) {
        imports.addAll(import);
      }
    }
    return imports;
  }
}

String? argumentAllocation(ArgumentProxy arg) {
  if (arg.needsAllocation) {
    var ffiType = getFFIType(arg, forPtrCall: true);
    final argName = escapeName(arg.name).toLowerCamelCase();
    final bang = arg.defaultArgumentValue != null ? '!' : '';
    final value = arg.typeCategory == TypeCategory.enumType ||
            arg.typeCategory == TypeCategory.bitfieldType
        ? '.value'
        : '';
    return 'final ${argName}Ptr = arena.allocate<$ffiType>(sizeOf<$ffiType>())..value = $argName$bang$value;';
  } else if (arg.typeCategory == TypeCategory.engineClass) {
    final argName = escapeName(arg.name).toLowerCamelCase();
    return 'final ${argName}Ptr = arena.allocate<GDExtensionObjectPtr>(sizeOf<GDExtensionObjectPtr>())..value = ($argName?.nativePtr ?? nullptr);';
  }
  return null;
}

void writeReturnAllocation(ArgumentProxy returnType, CodeSink o) {
  var returnTypeName = 'GDExtensionTypePtr';
  var sizeofString = 'sizeOf<GDExtensionTypePtr>()';

  switch (returnType.typeCategory) {
    case TypeCategory.voidType:
      throw Exception('Attempt to write return allocaiton for void.');
    case TypeCategory.primitive:
    case TypeCategory.enumType:
    case TypeCategory.bitfieldType:
      returnTypeName = getFFIType(returnType, forPtrCall: true)!;
      sizeofString = 'sizeOf<$returnTypeName>()';
      break;
    case TypeCategory.engineClass:
      // Otherwise use the default
      break;
    case TypeCategory.builtinClass:
      // Create the variant to write into. The return ptr is the memory
      // already allocated by the Variant
      final retType =
          returnType.type == 'String' ? 'GDString' : returnType.type;
      o.p('final retVal = $retType();');
      o.p('final retPtr = retVal.nativePtr;');
      return;
    case TypeCategory.nativeStructure:
      returnTypeName = returnType.rawDartType;
      sizeofString = 'sizeOf<${returnType.rawDartType}>()';
      break;
    case TypeCategory.typedArray:
      sizeofString = 'TypedArray.sTypeInfo.size';
      break;
  }

  o.p('final retPtr = arena.allocate<$returnTypeName>($sizeofString);');
}

void writeReturnRead(ArgumentProxy returnType, CodeSink o) {
  switch (returnType.typeCategory) {
    case TypeCategory.voidType:
      throw Exception('Attempt to write return read for void.');
    case TypeCategory.primitive:
    case TypeCategory.bitfieldType:
    case TypeCategory.nativeStructure:
      o.p('return retPtr.value;');
      break;
    case TypeCategory.engineClass:
      final question = returnType.isOptional ? '?' : '';
      if (returnType.isRefCounted) {
        o.p('final realObj = gde.ffiBindings.gde_ref_get_object(retPtr.cast());');
        o.p('final retVal = (realObj.cast<GDExtensionObjectPtr>().toDart()) as ${returnType.rawDartType}$question;');
        // Need to unreference the Ref<T> as its destructor is never called
        o.p('retVal$question.unreference();');
        o.p('return retVal;');
      } else {
        o.p('return retPtr.value.toDart() as ${returnType.rawDartType}$question;');
      }
      break;
    case TypeCategory.builtinClass:
      if (returnType.type == 'String' || returnType.type == 'StringName') {
        o.p('return retVal.toDartString();');
      } else {
        if (hasCustomImplementation(returnType.type)) {
          o.p('retVal.updateFromOpaque();');
        }
        o.p('return retVal;');
      }
      break;
    case TypeCategory.enumType:
      o.p('return ${returnType.rawDartType}.fromValue(retPtr.value);');
      break;
    case TypeCategory.typedArray:
      o.p('return ${returnType.rawDartType}.copyPtr(retPtr.cast());');
      break;
  }
}

void writeArgumentAllocations(List<ArgumentProxy> arguments, CodeSink out) {
  for (final arg in arguments) {
    final alloc = argumentAllocation(arg);
    if (alloc != null) out.p(alloc);
  }
}

void withAllocationBlock(
  List<ArgumentProxy> arguments,
  ArgumentProxy? retInfo,
  CodeSink out,
  void Function() writeBlock,
) {
  var needsArena = retInfo?.typeCategory != TypeCategory.voidType ||
      arguments.any((arg) => arg.needsAllocation);
  if (needsArena) {
    final hasReturn =
        retInfo != null && retInfo.typeCategory != TypeCategory.voidType;
    final retString = hasReturn ? 'return ' : '';
    out.b('${retString}using((arena) {', () {
      writeBlock();
    }, '});');
  } else {
    writeBlock();
  }
}

/// Generate a constructor name from arguments types. In the case
/// of a single argument constructor of the same type, the constructor
/// is called 'copy'. Otherwise it is named '.from{ArgType1}{ArgType2}'
String getConstructorName(String type, Constructor constructor) {
  final arguments = constructor.arguments;
  if (arguments != null && arguments.isNotEmpty) {
    if (arguments.length == 1) {
      var argument = arguments[0];
      if (argument.type == type) {
        return '.copy';
      } else if (argument.type == 'String') {
        return '.fromGDString';
      }
      return '.from${argument.type}';
    } else {
      var name = '.from';
      for (final arg in arguments) {
        var argName = escapeName(arg.name).toLowerCamelCase();
        name += argName[0].toUpperCase() + argName.substring(1);
      }
      return name;
    }
  }

  return '';
}

String getDartMethodName(String name, bool isVirtual) {
  if (isVirtual && name.startsWith('_')) {
    name = name.replaceFirst('_', 'v_');
  }

  name = escapeMethodName(name).toLowerCamelCase();
  return name;
}

String getArgumentDefaultValue(ArgumentProxy arg, String defaultValue) {
  if (arg.typeCategory == TypeCategory.enumType) {
    return GodotApiInfo.instance()
        .findEnumValue(arg.dartType, arg.defaultArgumentValue!);
  }

  final argumentCapture = RegExp(r'.+\((?<args>.+)\)');
  switch (arg.type) {
    case 'Variant':
      if (defaultValue == 'null') return 'Variant()';
      if (defaultValue == '0') return 'Variant(0)';
      break;
    case 'Vector2':
    case 'Vector2i':
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        return '${arg.type}.fromXY($args)';
      }
      break;
    case 'Vector3':
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        final parts = args.split(',');
        return 'Vector3(x: ${parts[0]}, y: ${parts[1]}, z: ${parts[2]})';
      }
      break;
    case 'Transform2D':
      // Transform2d says its default value is 6 values then doesn't have a constructor
      // that takes 6 values, go figure
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        final parts = args.split(',');
        return 'Transform2D.fromXAxisYAxisOrigin('
            'Vector2.fromXY(${parts[0]}, ${parts[1]}), '
            'Vector2.fromXY(${parts[2]}, ${parts[3]}), '
            'Vector2.fromXY(${parts[4]}, ${parts[5]}),)';
      }
      break;
    case 'Transform3D':
      // Transform2d says its default value is 12 values then doesn't have a constructor
      // that takes 12 values, go figure
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        final parts = args.split(',');
        return 'Transform3D.fromXAxisYAxisZAxisOrigin('
            'Vector3(x: ${parts[0]}, y: ${parts[1]}, z: ${parts[2]}), '
            'Vector3(x: ${parts[3]}, y: ${parts[4]}, z: ${parts[5]}), '
            'Vector3(x: ${parts[6]}, y: ${parts[7]}, z: ${parts[8]}), '
            'Vector3(x: ${parts[9]}, y: ${parts[10]}, z: ${parts[11]}),)';
      }
      break;
    case 'NodePath':
      // Transform2d says its default value is 6 values then doesn't have a constructor
      // that takes 6 values, go figure
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        // TOOD: Replace with NodePath.fromString when possible
        return 'NodePath.fromGDString(GDString.fromString(${args.replaceAll('"', "'")}))';
      }
      break;
    case 'Color':
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        return 'Color.fromRGBA($args)';
      }
      break;
    case 'Rect2':
    case 'Rect2i':
      final args = argumentCapture.firstMatch(defaultValue)?.namedGroup('args');
      if (args != null) {
        return '${arg.type}.fromXYWidthHeight($args)';
      }
      break;
    case 'String':
    case 'StringName':
      if (defaultValue == '&""') return "''";
      return defaultValue.replaceAll('"', "'").replaceAll('&', '');
    case 'Array':
      if (defaultValue == '[]') return 'Array()';
      break;
    case 'Dictionary':
      if (defaultValue == '{}') return 'Dictionary()';
      break;
  }

  if (arg.type.startsWith('typedarray::')) {
    final typedArrayArgumentCapture =
        RegExp(r'Array\[(?<type>.+)\]\((?<arg>.+)\)');
    final arrayArguments =
        typedArrayArgumentCapture.firstMatch(arg.defaultArgumentValue!);
    if (arrayArguments?.namedGroup('arg') == '[]' ||
        arg.defaultArgumentValue == '[]') {
      return '${arg.dartType}()';
    }
  }

  return defaultValue;
}

void assignMethodDefaults(List<ArgumentProxy> arguments, CodeSink o) {
  bool needsDefaultAssignment(ArgumentProxy a) {
    return a.defaultArgumentValue != null &&
        !isPrimitiveType(a.dartType) &&
        !a.isOptional;
  }

  for (final arg in arguments.where((a) => needsDefaultAssignment(a))) {
    final argName = escapeName(arg.name).toLowerCamelCase();
    final defaultValue =
        getArgumentDefaultValue(arg, arg.defaultArgumentValue!);
    o.p('$argName ??= $defaultValue;');
  }
}

extension ClassMethodConverter on BuiltinClassMethod {
  ClassMethod asMethodData() {
    return ClassMethod(
      name: name,
      isConst: isConst,
      isVararg: isVararg,
      isStatic: isStatic,
      isVirtual: false,
      hash: hash,
      returnValue: returnType == null ? null : ReturnValue(type: returnType!),
      arguments: arguments,
    );
  }
}

extension UtilityMethodConverter on UtilityFunction {
  ClassMethod asMethodData() {
    return ClassMethod(
      name: name,
      isConst: false,
      isVararg: isVararg,
      isStatic: true,
      isVirtual: false,
      hash: hash,
      returnValue: returnType == null
          ? null
          : ReturnValue(type: returnTypeValues.reverse[returnType!]!),
      arguments:
          arguments?.map((e) => Argument(name: e.name, type: e.type)).toList(),
    );
  }
}

String makeSignature(dynamic functionData, {bool useGodotStringTypes = false}) {
  assert(functionData is BuiltinClassMethod ||
      functionData is ClassMethod ||
      functionData is UtilityFunction);
  ClassMethod methodData;
  if (functionData is ClassMethod) {
    methodData = functionData;
  } else if (functionData is BuiltinClassMethod) {
    methodData = functionData.asMethodData();
  } else if (functionData is UtilityFunction) {
    methodData = functionData.asMethodData();
  } else {
    return '';
  }

  var modifiers = '';
  if (methodData.isStatic) {
    modifiers += 'static ';
  }
  final methodName = getDartMethodName(methodData.name, methodData.isVirtual);

  var returnType = 'void';
  if (methodData.returnValue != null) {
    returnType = methodData.returnValue!.proxy.dartType;
  }

  var signature = '$modifiers$returnType $methodName(';

  final parameters = methodData.arguments;
  List<String> positionalParamSignature = [];
  List<String> namedParamSignature = [];
  if (parameters != null) {
    for (int i = 0; i < parameters.length; ++i) {
      final parameter = parameters[i];

      var type = parameter.proxy.dartType;
      if (useGodotStringTypes && type == 'String') {
        type = parameter.proxy.type;
      }

      if (parameter.defaultValue == null) {
        positionalParamSignature
            .add('$type ${escapeName(parameter.name).toLowerCamelCase()}');
      } else {
        if (parameter.proxy.isOptional) {
          // Don't double opt.
          namedParamSignature
              .add('$type ${escapeName(parameter.name).toLowerCamelCase()}');
        } else {
          if (isPrimitiveType(parameter.proxy.dartType)) {
            namedParamSignature.add(
                '$type ${escapeName(parameter.name).toLowerCamelCase()} = ${getArgumentDefaultValue(parameter.proxy, parameter.defaultValue!)}');
          } else {
            namedParamSignature
                .add('$type? ${escapeName(parameter.name).toLowerCamelCase()}');
          }
        }
      }
    }
  }

  if (methodData.isVararg) {
    namedParamSignature.add('List<Variant> vargs = const []');
  }

  if (positionalParamSignature.isNotEmpty) {
    signature += positionalParamSignature.join(', ');
  }
  if (namedParamSignature.isNotEmpty) {
    if (positionalParamSignature.isNotEmpty) signature += ', ';
    signature += '{${namedParamSignature.join(', ')}}';
  }

  signature += ')';

  return signature;
}

String nakedType(String type) {
  if (type.startsWith('const')) {
    type = type.replaceFirst('const', '');
  }
  while (type.endsWith('*')) {
    type = type.substring(0, type.length - 1);
  }

  return type.trim();
}

List<String> getUsedTypes(Map<String, dynamic> api) {
  var usedTypes = <String>{};
  var inherits = api['inherits'] as String?;
  if (inherits != null) {
    usedTypes.add(inherits);
  }

  if (api['constructors'] != null) {
    final constructors = api['constructors'] as List<dynamic>;
    for (Map<String, dynamic> constructor
        in constructors.map((e) => e as Map<String, dynamic>)) {
      if (constructor['arguments'] != null) {
        final args = constructor['arguments'] as List<dynamic>;
        for (Map<String, dynamic> arg
            in args.map((e) => e as Map<String, dynamic>)) {
          usedTypes.add(nakedType(arg['type'] as String));
        }
      }
    }
  }

  if (api['methods'] != null) {
    final methods = api['methods'] as List<dynamic>;
    for (Map<String, dynamic> method
        in methods.map((e) => e as Map<String, dynamic>)) {
      if (method['arguments'] != null) {
        final args = method['arguments'] as List<dynamic>;
        for (Map<String, dynamic> arg
            in args.map((e) => e as Map<String, dynamic>)) {
          usedTypes.add(nakedType(arg['type'] as String));
        }
      }
      if (method['return_type'] != null) {
        usedTypes.add(nakedType(method['return_type'] as String));
      } else if (method['return_value'] != null) {
        final returnValue = method['return_value'] as Map<String, dynamic>;
        usedTypes.add(nakedType(returnValue['type'] as String));
      }
    }
  }

  if (api['members'] != null) {
    final members = api['members'] as List<dynamic>;
    for (Map<String, dynamic> member
        in members.map((e) => e as Map<String, dynamic>)) {
      usedTypes.add(nakedType(member['type'] as String));
    }
  }

  // Typed arrays and enums
  if (usedTypes.any((e) => e.startsWith('typedarray::'))) {
    final typedArraySet = <String>{};
    for (var type in usedTypes) {
      if (type.startsWith('typedarray::')) {
        final typeParameter = type.split('::')[1];
        typedArraySet.add(typeParameter);
      }
    }
    usedTypes.removeWhere((e) => e.startsWith('typedarray::'));
    usedTypes.addAll(typedArraySet);
    usedTypes.add('TypedArray');
  }

  final enumAndBitfieldTypes = <String>[];
  for (var type in usedTypes
      .where((e) => e.startsWith('enum::') || e.startsWith('bitfield::'))) {
    if (type.contains('.')) {
      final parentClass = type
          .replaceAll('enum::', '')
          .replaceAll('bitfield::', '')
          .split('.')
          .first;
      // Special case -- enum::Variant.Type is held in GlobalConstants
      if (parentClass == 'Variant') {
        enumAndBitfieldTypes.add('GlobalConstants');
      } else {
        enumAndBitfieldTypes.add(parentClass);
      }
    } else {
      enumAndBitfieldTypes.add('GlobalConstants');
    }
  }
  usedTypes
      .removeWhere((e) => e.startsWith('enum::') || e.startsWith('bitfield::'));
  usedTypes.addAll(enumAndBitfieldTypes);

  usedTypes.remove('void');

  usedTypes.removeAll(dartTypes);
  // Already included
  usedTypes.remove('StringName');

  return usedTypes.toList();
}

String createPtrcallArguments(CodeSink o, List<ArgumentProxy>? arguments) {
  final variableName = 'ptrArgArray';
  if (arguments == null || arguments.isEmpty) {
    o.p('Pointer<Pointer<Void>> $variableName = nullptr;');
    return variableName;
  }

  assignMethodDefaults(arguments, o);
  o.p('final $variableName = arena.allocate<GDExtensionConstTypePtr>(sizeOf<GDExtensionConstTypePtr>() * ${arguments.length});');
  arguments.forEachIndexed((i, argument) {
    convertDartToPtrArgument('(ptrArgArray + $i)', argument, o);
  });

  return variableName;
}

void convertDartToPtrArgument(
    String argumentName, ArgumentProxy argument, CodeSink o) {
  // Special case, converting to Dart strings from GDString or StringName
  final varName = escapeName(argument.name).toLowerCamelCase();
  if (argument.type == 'String') {
    o.p('final gd$varName = GDString.fromString($varName);');
    o.p('$argumentName.value = gd$varName.nativePtr.cast();');
    return;
  } else if (argument.type == 'StringName') {
    o.p('final gd$varName = StringName.fromString($varName);');
    o.p('$argumentName.value = gd$varName.nativePtr.cast();');
    return;
  }

  switch (argument.typeCategory) {
    case TypeCategory.voidType:
      throw Exception('Invalid voidType as argument!');
    case TypeCategory.primitive:
      var ffiType = getFFIType(argument, forPtrCall: true);
      if (ffiType == null && argument.isPointer) {
        ffiType = 'Pointer<Void>';
      }
      o.p('final ${varName}Ptr = arena.allocate<$ffiType>(sizeOf<$ffiType>())..value = $varName;');
      o.p('$argumentName.value = ${varName}Ptr.cast();');
      break;
    case TypeCategory.engineClass:
      // NB: -- We don't do anything with Ref for RefCounted objects because, by
      // 'chance' a Ref only contains a pointer to the member, so passing in the
      // object pointer without using Ref as a wrapper works, but might fail
      // sometime in the future if we're not careful.
      final value = argument.isOptional
          ? '$varName?.nativePtr ?? nullptr'
          : '$varName.nativePtr';
      o.p('final ${varName}Ptr = arena.allocate<GDExtensionConstTypePtr>(sizeOf<GDExtensionObjectPtr>())..value = $value;');
      o.p('$argumentName.value = ${varName}Ptr.cast();');
      break;
    case TypeCategory.builtinClass:
      final bang = argument.defaultArgumentValue != null ? '!' : '';
      //final optional = argument.isOptional ? ' ?? nullptr' : '';
      o.p('$argumentName.value = $varName$bang.nativePtr.cast();');
      break;
    case TypeCategory.nativeStructure:
      if (argument.isPointer) {
        o.p('final ${varName}Ptr = arena.allocate<GDExtensionPtr>(sizeOf<GDExtensionConstTypePtr>())..value = $varName.nativerPtr;');
        o.p('$argumentName.value = ${varName}Ptr;');
      } else {
        final optional = argument.isOptional ? ' ?? nullptr' : '';
        o.p('$argumentName.value = $varName.nativePtr$optional;');
      }
      break;
    case TypeCategory.enumType:
      final bang = argument.defaultArgumentValue != null ? '!' : '';
      o.p('final ${varName}Ptr = arena.allocate<Uint32>(sizeOf<Uint32>())..value = $varName$bang.value;');
      o.p('$argumentName.value = ${varName}Ptr.cast();');
      break;
    case TypeCategory.bitfieldType:
      o.p('final ${varName}Ptr = arena.allocate<Uint32>(sizeOf<Uint32>())..value = $varName;');
      o.p('$argumentName.value = ${varName}Ptr.cast();');
      break;
    case TypeCategory.typedArray:
      if (argument.isOptional) {
        o.p('$argumentName.value = $varName?.nativePtr?.cast() ?? nullptr;');
      } else {
        final bang = argument.defaultArgumentValue != null ? '!' : '';
        o.p('$argumentName.value = $varName$bang.nativePtr.cast();');
      }
      break;
  }
}

// A map of enumTypes to prefixes that are different from their type name, and
// can be removed in Dart.
const removePrefixes = <String, String>{
  'KeyModifierMask': 'keyMask',
  'Variant.Type': 'type',
  'Error': 'err',
  'MethodFlags': 'methodFlag',
  'PropertyUsageFlags': 'propertyUsage',
  'Variant.Operator': 'op',
  'Planes': 'plane',
};

// Reserved words that get used as enum names, and should instead
// default back to their original, prefixed names.
final reservedWordEnumNames = [
  'default',
  'const',
  'static',
  'in',
  'index',
  'new',
  'class',
  'continue',
];

Value _transformEnumValues(Value e, String name) {
  final lowerEnumName = name.lowerFirstLetter();
  String originalName = e.name.toLowerCamelCase();
  String transformedName = originalName;
  if (originalName != lowerEnumName && originalName.startsWith(lowerEnumName)) {
    transformedName =
        originalName.replaceFirst(lowerEnumName, '').lowerFirstLetter();
  } else if (removePrefixes.containsKey(name)) {
    final prefix = removePrefixes[name]!;
    transformedName =
        transformedName.replaceFirst(prefix, '').lowerFirstLetter();
  }

  // Don't allow keywords
  if (transformedName == 'int') transformedName = 'integer';
  if (transformedName == 'enum') transformedName = 'enumVal';
  if (reservedWordEnumNames.contains(transformedName)) {
    transformedName = originalName;
  }

  return Value(name: transformedName, value: e.value);
}

extension EnumTransform on BuiltinClassEnum {
  List<Value> transformedValues() {
    return values.map((e) => _transformEnumValues(e, name)).toList();
  }
}

extension EnumTranform on GlobalEnumElement {
  List<Value> transformedValues() {
    return values.map((e) => _transformEnumValues(e, name)).toList();
  }
}

void writeEnum(dynamic godotEnum, String? inClass, CodeSink o) {
  String name;
  List<Value> valueList;
  bool isBitfield = false;
  if (godotEnum is BuiltinClassEnum) {
    name = godotEnum.name;
    valueList = godotEnum.transformedValues();
  } else if (godotEnum is GlobalEnumElement) {
    name = godotEnum.name;
    valueList = godotEnum.transformedValues();
    isBitfield = godotEnum.isBitfield;
  } else {
    throw ArgumentError(
        'Trying to write an enum that is of type ${godotEnum.runtimeType}');
  }

  var enumName = getEnumName(name, inClass);

  o.b('enum $enumName {', () {
    if (isBitfield && valueList.where((e) => e.name == 'none').isEmpty) {
      o.p('none(0),');
    }
    for (int i = 0; i < valueList.length; ++i) {
      final value = valueList[i];
      final end = i == valueList.length - 1 ? ';' : ',';
      o.p('${value.name}(${value.value})$end');
    }
    o.nl();

    o.p("@pragma('vm:entry-point')");
    o.p('final int value;');
    o.p('const $enumName(this.value);');
    o.b('factory $enumName.fromValue(int value) {', () {
      o.p('return values.firstWhere((e) => e.value == value);');
    }, '}');

    o.b('static final sTypeInfo = PrimitiveTypeInfo<$enumName>(', () {
      o.p("className: StringName.fromString('$enumName'),");
      o.p('variantType: GDExtensionVariantType.GDEXTENSION_VARIANT_TYPE_INT,');
      o.p('fromPointer: (ptr) => $enumName.fromValue(ptr.cast<Int32>().value),');
      o.p('toPointer: (self, ptr) => ptr.cast<Int32>().value = self.value');
    }, ');');
  }, '}');
}
